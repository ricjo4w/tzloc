#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>

// Header-only JSON for simplicity (generator-only dependency).
// You can vendor this header or fetch it in CMake.
// https://github.com/nlohmann/json (MIT)
#include <nlohmann/json.hpp>
using nlohmann::json;

/*
 * Input:  GeoJSON from timezone-boundary-builder (FeatureCollection).
 *         - Each Feature has properties.tzid (or "tzid" or "tzid_alt"; most commonly "tzid")
 *         - geometry.type in {"Polygon", "MultiPolygon"}
 *         - geometry.coordinates: per GeoJSON spec (lon, lat) order; rings are closed.
 * Output: C++ source file "generated_tz_data.cpp" that defines tzdb_gen::build(...)
 *         which fills vectors of Boost polygons and tzids.
 *
 * Notes:
 *  - We keep GeoJSON ring orientation (outer CCW, inner CW). Boostâ€™s Polygon here expects CCW exterior.
 *    If the source ring is not CCW for exterior, we can rely on bg::correct(...) at runtime if needed.
 *  - We do not apply any projection; coordinates are used as planar lon/lat.
 */

static void write_prologue(std::ostream& os) {
    os <<
R"(// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by tools/gen_tz.cpp from your timezone GeoJSON.
// Contains baked polygon data and tzids for TimezoneLocator.

#include "TimezoneLocator.hpp"
#include <string>
#include <vector>

namespace tzdb_gen {

using tzloc::Point;
using tzloc::Polygon;

void build(std::vector<tzloc::Polygon>& out_polys,
           std::vector<std::string>& out_tzids) {
    out_polys.clear();
    out_tzids.clear();
    out_polys.reserve()";
}

static void write_epilogue(std::ostream& os) {
    os << R"(    ;
}

} // namespace tzdb_gen
)";
}

static void add_ring(std::ostream& os, const json& ring) {
    // ring: array of [lon, lat] pairs; may be closed (duplicated first/last)
    // We'll ensure closed==true by repeating first point if needed.
    os << "        poly.outer().clear();\n";
    if (!ring.is_array()) throw std::runtime_error("ring is not array");

    if (ring.size() < 3) return; // degenerate, ignore

    // Detect if last equals first; if not, we will close it later.
    auto lon0 = ring.at(0).at(0).get<double>();
    auto lat0 = ring.at(0).at(1).get<double>();
    auto lonN = ring.back().at(0).get<double>();
    auto latN = ring.back().at(1).get<double>();
    bool closed = (lon0 == lonN) && (lat0 == latN);

    size_t end = closed ? ring.size() - 1 : ring.size();
    for (size_t i = 0; i < end; ++i) {
        double lon = ring.at(i).at(0).get<double>();
        double lat = ring.at(i).at(1).get<double>();
        os << "        poly.outer().push_back(Point(" << lon << ", " << lat << "));\n";
    }
    // Close explicitly (Polygon template uses Closed=true)
    os << "        poly.outer().push_back(Point(" << lon0 << ", " << lat0 << "));\n";
}

static void add_holes(std::ostream& os, const json& rings) {
    // rings[0] = outer, rings[1..] = holes
    for (size_t r = 1; r < rings.size(); ++r) {
        const auto& ring = rings.at(r);
        if (!ring.is_array() || ring.size() < 3) continue;
        auto lon0 = ring.at(0).at(0).get<double>();
        auto lat0 = ring.at(0).at(1).get<double>();
        auto lonN = ring.back().at(0).get<double>();
        auto latN = ring.back().at(1).get<double>();
        bool closed = (lon0 == lonN) && (lat0 == latN);

        os << "        poly.inners().emplace_back();\n";
        os << "        poly.inners().back().clear();\n";

        size_t end = closed ? ring.size() - 1 : ring.size();
        for (size_t i = 0; i < end; ++i) {
            double lon = ring.at(i).at(0).get<double>();
            double lat = ring.at(i).at(1).get<double>();
            os << "        poly.inners().back().push_back(Point(" << lon << ", " << lat << "));\n";
        }
        // close hole
        os << "        poly.inners().back().push_back(Point(" << lon0 << ", " << lat0 << "));\n";
    }
}

int main(int argc, char** argv) {
    if (argc != 3) {
        std::cerr << "Usage: gen_tz <input_timezone_geojson> <output_cpp>\n";
        return 2;
    }
    const std::string in_path  = argv[1];
    const std::string out_path = argv[2];

    // Load GeoJSON
    std::ifstream ifs(in_path);
    if (!ifs) {
        std::cerr << "ERROR: cannot open " << in_path << "\n";
        return 1;
    }
    json j;
    ifs >> j;

    if (!j.contains("features") || !j["features"].is_array()) {
        std::cerr << "ERROR: input is not a FeatureCollection with 'features'\n";
        return 1;
    }

    // Count total polygon parts for reserve() hint
    size_t poly_count = 0;
    for (const auto& f : j["features"]) {
        const auto& geom = f["geometry"];
        const std::string type = geom["type"].get<std::string>();
        if (type == "Polygon") {
            ++poly_count;
        } else if (type == "MultiPolygon") {
            poly_count += geom["coordinates"].size();
        }
    }

    std::ofstream os(out_path, std::ios::trunc);
    if (!os) {
        std::cerr << "ERROR: cannot open " << out_path << " for write\n";
        return 1;
    }

    write_prologue(os);
    os << "(" << poly_count << ")";
    os << R"(

    // For each polygon part we emit a Polygon and a matching tzid.
    tzloc::Polygon poly;
    std::string tzid;

)";

    // Emit polygons
    for (const auto& f : j["features"]) {
        const auto& props = f["properties"];
        std::string tzid = props.contains("tzid") ? props["tzid"].get<std::string>()
                         : (props.contains("TZID") ? props["TZID"].get<std::string>()
                         : (props.contains("name") ? props["name"].get<std::string>()
                         : std::string{}));
        if (tzid.empty()) {
            std::cerr << "WARN: feature missing tzid; skipping\n";
            continue;
        }

        const auto& geom = f["geometry"];
        const std::string type = geom["type"].get<std::string>();

        if (type == "Polygon") {
            const auto& rings = geom["coordinates"]; // [ [ [lon,lat]... ], [hole]... ]
            os << "    // Feature: " << tzid << "\n";
            os << "    poly = tzloc::Polygon{};\n";
            add_ring(os, rings.at(0));
            add_holes(os, rings);
            os << "    out_polys.push_back(poly);\n";
            os << "    out_tzids.push_back(std::string{" << std::quoted(tzid) << "});\n\n";

        } else if (type == "MultiPolygon") {
            const auto& polys = geom["coordinates"]; // [ [rings], [rings], ... ]
            size_t part = 0;
            for (const auto& rings : polys) {
                os << "    // Feature: " << tzid << " (part " << part++ << ")\n";
                os << "    poly = tzloc::Polygon{};\n";
                add_ring(os, rings.at(0));
                add_holes(os, rings);
                os << "    out_polys.push_back(poly);\n";
                os << "    out_tzids.push_back(std::string{" << std::quoted(tzid) << "});\n\n";
            }
        } else {
            std::cerr << "WARN: geometry type " << type << " ignored\n";
        }
    }

    write_epilogue(os);
    std::cerr << "Wrote " << out_path << " with " << poly_count << " polygons\n";
    return 0;
}
